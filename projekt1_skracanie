#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <locale.h>
#include <time.h>

void wspolczynniki(float* dane, float* rozdzielczosc) {
	do {
		printf("Podaj wspolczynnik A: ");
		scanf("%f", &dane[0]);
	}
	while (dane[0] == 0);

	do
	{
		printf("Podaj wspolczynnik B: ");
		scanf("%f", &dane[1]);
	}
	while (dane[1] == 0);

	printf("Podaj wspolczynnik C: ");
	scanf("%f", &dane[2]);
	printf("Podaj rozdzielczosc: ");
	scanf("%f", rozdzielczosc);


}

void granice(float* xmin, float* xmax) {
	do
	{
		printf("Podaj lewa granice: ");
		scanf("%f", xmin);
		printf("Podaj prawa granice: ");
		scanf("%f", xmax);
	}
	while (*xmax <= *xmin);
}

void generator(float* sygnal, float* dane, float xmin, float xmax, float rozdzielczosc, int* probki) {

	for (int i = 0; i < *probki; i++) {
		sygnal[i] = dane[0] * sin((xmin + i * rozdzielczosc) / dane[0]) + dane[1] * cos((xmin + i * rozdzielczosc) / dane[1]) + dane[2];
	}

}


void naprawa(float xmin, float xmax, float rozdzielczosc, int* probki) {
	*probki = (xmax - xmin) / rozdzielczosc;
	*probki = *probki + 1;
}

void szum(float* sygnal, float* sygnal_szum, int probki, float* wspolczynniki) {
	int prawdopodobienstwo;
	int zmienna;
	int szum;
	printf("Podaj prawdopodobieństwo szumu (procent): ");
	scanf("%d", &prawdopodobienstwo);

	for (int i = 0; i < probki; i++) {
		zmienna = rand() % 100 + 1;

		if (zmienna < prawdopodobienstwo + 1) {

			szum = rand() % 5 + 1;
			sygnal_szum[i] = sygnal[i] + szum;
		}
		else
			sygnal_szum[i] = sygnal[i];

	}
}


void zapis(float* sygnal, float* sygnal_szum, int ilosc_probek, float xmin, float rozdzielczosc) {
	float x;
	if (sygnal_szum == NULL) {
		FILE* plik;
		plik = fopen("sygnal.csv", "w");
		if (plik == NULL)
		{
			printf("blad");
			return;
		}
		for (int i = 0; i < ilosc_probek; i++) {
			x = xmin + i * rozdzielczosc;
			fprintf(plik, "%f;%f\n", x, sygnal[i]);
		}
		fclose(plik);
	}
	else {
		FILE* plik;
		plik = fopen("sygnal.csv", "w");
		if (plik == NULL)
		{
			printf("blad");
			return;
		}
		for (int i = 0; i < ilosc_probek; i++) {
			x = xmin + i * rozdzielczosc;
			fprintf(plik, "%f;%f;%f\n", x, sygnal[i], sygnal_szum[i]);
		}
		fclose(plik);
	}
}

void skracanie(int* probki) {
	printf("Podaj nowa liczbe probek (mniejsza niz %d): ", *probki);
	scanf("%d", probki);
}

int main() {
	setlocale(LC_ALL, "polish_poland");
	srand(time(NULL));
	float dane[3];
	float xmin, xmax;
	float* sygnal = NULL;
	float* sygnal_szum = NULL;
	float n;
	int probki = 0;
	int menu = -1;
	while (menu != 4) {
		printf("Wybierz opcje:\n1. Generuj sygnał podstawowy\n2. Wygeneruj szum\n3. Zapis do pliku\n4. Zakończenie programu\n5. Skracanie sygnalu (brak zabezpieczen)\n");
		scanf("%d", &menu);
		switch (menu) {
		case 1:
			wspolczynniki(dane, &n);
			granice(&xmin, &xmax);
			do {
				naprawa(xmin, xmax, n, &probki);
				if (probki < 10) {
					printf("Liczba próbek jest zbyt mała. Podaj inną rozdzielczość: ");
					scanf("%f", &n);
				}
			} while (probki < 10);
			sygnal = malloc(probki * sizeof(float));
			generator(sygnal, dane, xmin, xmax, n, &probki);
			printf("Wygenerowano sygnał.\n");
			break;
		case 2:
			if (sygnal == NULL) {
				printf("Brak sygnału do wygenerowania szumu.\n");
				break;
			}
			sygnal_szum = malloc(probki * sizeof(float));
			szum(sygnal, sygnal_szum, probki, dane);
			printf("Wygenerowano szum.\n");
			break;
		case 3:
			zapis(sygnal, sygnal_szum, probki, xmin, n);
			printf("Utworzono plik.\n");
			break;
		case 4:
			printf("Zakończenie programu.");
			break;
		case 5:
			skracanie(&probki);
			sygnal = realloc(sygnal, probki * sizeof(float));
			printf("Skrócono sygnał.\n");
			break;
		default:
			printf("Nieprawidłowa opcja. Spróbuj ponownie.");
		}
	}

	free(sygnal);
	free(sygnal_szum);
	return 0;
}
